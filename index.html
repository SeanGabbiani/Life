<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Life – Conway’s Game of Life</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#000000" />

  <style>
    :root {
      --bg: #050608;
      --toolbar-bg: #111319;
      --button-bg: #1b1e27;
      --button-border: #2a2e3a;
      --button-text: #f5f5f5;
      --accent: #27e8a7;
      --grid-dead: #050608;
      --grid-alive: #27e8a7;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: var(--bg);
      color: var(--button-text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Helvetica Neue", Arial, sans-serif;
      overflow: hidden;
    }

    #app {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }

    /* Toolbar */

    #toolbar {
      background: var(--toolbar-bg);
      padding: 8px 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.03);
      z-index: 10;
    }

    .btn {
      border-radius: 14px;
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      white-space: nowrap;
    }

    .btn.small {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 10px;
    }

    .btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(39, 232, 167, 0.3);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .spacer {
      flex: 1;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .slider-group label {
      font-size: 12px;
      opacity: 0.7;
    }

    .slider-group input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 140px;
      height: 4px;
      border-radius: 999px;
      background: #232735;
      outline: none;
    }

    .slider-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
    }

    /* Grid */

    #grid-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #grid {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      touch-action: none;
      background: var(--grid-dead);
    }

    /* Bestiary overlay */

    #bestiaryOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.78);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #bestiaryOverlay.open {
      display: flex;
    }

    .bestiary-panel {
      background: #111319;
      border-radius: 16px;
      padding: 16px;
      width: min(460px, 90vw);
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      gap: 10px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      overflow-y: auto;
    }

    .bestiary-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .bestiary-title {
      font-weight: 600;
      font-size: 15px;
    }

    .bestiary-note {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 4px;
    }

    .pattern-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    /* Tiny corner UI toggle */

    .corner-toggle {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid #2a2e3a;
      background: #1b1e27;
      color: #cccccc;
      font-size: 18px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      cursor: pointer;
      z-index: 30;
    }

    .corner-toggle:active {
      transform: translateY(1px);
    }

    .corner-toggle:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <button class="btn" id="paintBtn">Paint</button>
      <button class="btn" id="eraseBtn">Erase</button>
      <button class="btn" id="randomBtn">Random</button>
      <button class="btn" id="clearBtn">Clear</button>
      <button class="btn" id="bestiaryBtn">Bestiary</button>
      <button class="btn" id="runBtn">Run</button>

      <div class="spacer"></div>

      <div class="slider-group">
        <label for="speedSlider">Speed</label>
        <input id="speedSlider" type="range" min="50" max="800" value="200" />
      </div>

      <div class="slider-group">
        <label for="cellSlider">Cell</label>
        <input id="cellSlider" type="range" min="6" max="24" value="12" />
      </div>
    </div>

    <div id="grid-container">
      <canvas id="grid"></canvas>

      <!-- Bestiary overlay -->
      <div id="bestiaryOverlay">
        <div class="bestiary-panel">
          <div class="bestiary-header">
            <span class="bestiary-title">Bestiary</span>
            <button class="btn small" id="closeBestiaryBtn">Close</button>
          </div>

          <p class="bestiary-note">Gliders</p>
          <div class="pattern-grid">
            <button class="btn small pattern-btn" data-pattern="gliderSE">Glider SE</button>
            <button class="btn small pattern-btn" data-pattern="gliderSW">Glider SW</button>
            <button class="btn small pattern-btn" data-pattern="gliderNE">Glider NE</button>
            <button class="btn small pattern-btn" data-pattern="gliderNW">Glider NW</button>
          </div>

          <p class="bestiary-note">Methuselahs</p>
          <div class="pattern-grid">
            <button class="btn small pattern-btn" data-pattern="methuselahRpentomino">R-pentomino</button>
            <button class="btn small pattern-btn" data-pattern="methuselahAcorn">Acorn</button>
            <button class="btn small pattern-btn" data-pattern="methuselahDiehard">Diehard</button>
          </div>

          <p class="bestiary-note">Spaceships</p>
          <div class="pattern-grid">
            <button class="btn small pattern-btn" data-pattern="spaceshipLWSS">LWSS</button>
            <button class="btn small pattern-btn" data-pattern="spaceshipMWSS">MWSS</button>
            <button class="btn small pattern-btn" data-pattern="spaceshipHWSS">HWSS</button>
          </div>

          <p class="bestiary-note">Guns & Engines</p>
          <div class="pattern-grid">
            <button class="btn small pattern-btn" data-pattern="gunGosper">Gosper gun</button>
            <button class="btn small pattern-btn" data-pattern="pufferTrain1">Puffer train</button>
            <button class="btn small pattern-btn" data-pattern="breeder1">Breeder</button>
          </div>

          <p class="bestiary-note">Machines</p>
          <div class="pattern-grid">
            <button class="btn small pattern-btn" data-pattern="tmArt">Turing machine (art)</button>
          </div>
        </div>
      </div>

      <!-- Tiny button to hide/show the toolbar -->
      <button id="toggleUiBtn" class="corner-toggle" title="Toggle toolbar">
        ⋮
      </button>
    </div>
  </div>

  <script>
    // -------- Patterns --------
    // Each pattern is an array of [row, col] (non-negative).
    // Stamping auto-centres around the click cell.

    const PATTERNS = {
      // --- GLIDERS (4 orientations) ---
      // SE (moves down-right)
      gliderSE: [
        [0, 1],
        [1, 2],
        [2, 0], [2, 1], [2, 2]
      ],
      // SW (down-left)
      gliderSW: [
        [0, 1],
        [1, 0],
        [2, 0], [2, 1], [2, 2]
      ],
      // NE (up-right)
      gliderNE: [
        [0, 0], [0, 1], [0, 2],
        [1, 0],
        [2, 1]
      ],
      // NW (up-left)
      gliderNW: [
        [0, 0], [0, 1], [0, 2],
        [1, 2],
        [2, 1]
      ],

      // --- Methuselahs ---
      // R-pentomino
      methuselahRpentomino: [
        [0, 1], [0, 2],
        [1, 0], [1, 1],
        [2, 1]
      ],

      // Acorn
      // . O . . . . .
      // . . . O . . .
      // O O . . O O O
      methuselahAcorn: [
        [0, 1],
        [1, 3],
        [2, 0], [2, 1],
        [2, 4], [2, 5], [2, 6]
      ],

      // Diehard
      // . . . . . . O .
      // O O . . . . . .
      // . . . . . O . .
      // . . . . . . O O
      methuselahDiehard: [
        [0, 6],
        [1, 0], [1, 1],
        [2, 5],
        [3, 6], [3, 7]
      ],

      // --- Spaceships ---
      // Lightweight spaceship (LWSS)
      // . O O O .
      // O . . . O
      // O . . . .
      // . O . O .
      spaceshipLWSS: [
        [0, 1], [0, 2], [0, 3],
        [1, 0], [1, 4],
        [2, 0],
        [3, 1], [3, 3]
      ],

      // Middleweight spaceship (MWSS)
      // . O O O O .
      // O . . . . O
      // O . . . . .
      // O . . . O .
      // . . O O . .
      spaceshipMWSS: [
        [0, 1], [0, 2], [0, 3], [0, 4],
        [1, 0], [1, 5],
        [2, 0],
        [3, 0], [3, 4],
        [4, 2], [4, 3]
      ],

      // Heavyweight spaceship (HWSS)
      // . O O O O O .
      // O . . . . . O
      // O . . . . . .
      // O . . . . O .
      // . . O O O . .
      spaceshipHWSS: [
        [0, 1], [0, 2], [0, 3], [0, 4], [0, 5],
        [1, 0], [1, 6],
        [2, 0],
        [3, 0], [3, 5],
        [4, 2], [4, 3], [4, 4]
      ],

      // --- Gosper Glider Gun ---
      gunGosper: [
        [5, 1], [5, 2], [6, 1], [6, 2],
        [5, 11], [6, 11], [7, 11],
        [4, 12],
        [3, 13], [3, 14],
        [8, 12],
        [9, 13], [9, 14],
        [6, 15],
        [4, 16], [5, 17], [6, 17], [7, 17],
        [6, 18],
        [8, 16],
        [3, 21], [4, 21], [5, 21],
        [3, 22], [4, 22], [5, 22],
        [2, 23], [6, 23],
        [1, 25], [2, 25], [6, 25], [7, 25],
        [3, 35], [4, 35],
        [3, 36], [4, 36]
      ],

      // --- Simple engine-like puffer train (toy) ---
      // This is a small constructed engine that sheds debris as it moves.
      // Not a canonical LifeWiki puffer train, but behaves like a puffer-ish engine.
      pufferTrain1: [
        [0, 1], [0, 2], [0, 3],
        [1, 0], [1, 4],
        [2, 0],
        [3, 1], [3, 3],
        [5, 2], [5, 3],
        [6, 2], [6, 3]
      ],

      // --- Simple breeder-ish pattern (toy) ---
      // A cluster of small engines that tends to seed expanding activity.
      breeder1: [
        // centre cluster
        [0, 0], [0, 1], [0, 2],
        [1, 0],
        [2, 1],
        // neighbours that help create repeating debris
        [0, 6], [0, 7],
        [1, 6],
        [3, 4], [3, 5], [3, 6],
        [4, 4]
      ],

      // --- Turing machine art piece (stylised, not functional TM) ---
      // Just a tape + head structure for visual effect.
      tmArt: [
        // tape line
        [0, -6 + 6], [0, -5 + 6], [0, -4 + 6], [0, -3 + 6], [0, -2 + 6], [0, -1 + 6],
        [0, 0 + 6], [0, 1 + 6], [0, 2 + 6], [0, 3 + 6], [0, 4 + 6], [0, 5 + 6],
        // head "box"
        [ -2 + 4, 0 + 6], [ -2 + 4, 1 + 6],
        [ -1 + 4, -1 + 6], [ -1 + 4, 2 + 6],
        [ 0 + 4, 0 + 6], [ 0 + 4, 1 + 6]
      ]
    };

    // -------- Core Game of Life logic --------

    const canvas = document.getElementById("grid");
    const ctx = canvas.getContext("2d");

    const toolbar = document.getElementById("toolbar");
    const paintBtn = document.getElementById("paintBtn");
    const eraseBtn = document.getElementById("eraseBtn");
    const randomBtn = document.getElementById("randomBtn");
    const clearBtn = document.getElementById("clearBtn");
    const bestiaryBtn = document.getElementById("bestiaryBtn");
    const runBtn = document.getElementById("runBtn");
    const toggleUiBtn = document.getElementById("toggleUiBtn");

    const speedSlider = document.getElementById("speedSlider");
    const cellSlider = document.getElementById("cellSlider");

    const bestiaryOverlay = document.getElementById("bestiaryOverlay");
    const closeBestiaryBtn = document.getElementById("closeBestiaryBtn");
    const patternButtons = document.querySelectorAll(".pattern-btn");

    let cellSize = parseInt(cellSlider.value, 10);
    let rows = 0;
    let cols = 0;
    let grid = [];
    let running = false;
    let frameId = null;
    let paintMode = "paint";        // "paint" or "erase"
    let pointerDown = false;
    let toolbarHidden = false;

    // tool state: "paint" | "erase" | "stamp"
    let currentTool = "paint";
    let currentStamp = null;        // pattern name when stamping

    function createEmptyGrid(r, c) {
      const g = [];
      for (let y = 0; y < r; y++) {
        const row = new Array(c).fill(0);
        g.push(row);
      }
      return g;
    }

    function resizeGrid() {
      const container = document.getElementById("grid-container");
      const w = container.clientWidth || window.innerWidth;
      const h = container.clientHeight || window.innerHeight;

      const newCols = Math.max(1, Math.floor(w / cellSize));
      const newRows = Math.max(1, Math.floor(h / cellSize));

      canvas.width = w;
      canvas.height = h;

      if (rows === 0 || cols === 0) {
        rows = newRows;
        cols = newCols;
        grid = createEmptyGrid(rows, cols);
        drawGrid();
        return;
      }

      if (newRows === rows && newCols === cols) {
        drawGrid();
        return;
      }

      const oldRows = rows;
      const oldCols = cols;
      const oldGrid = grid;

      rows = newRows;
      cols = newCols;
      const newGrid = createEmptyGrid(rows, cols);

      const copyRows = Math.min(oldRows, newRows);
      const copyCols = Math.min(oldCols, newCols);

      for (let y = 0; y < copyRows; y++) {
        for (let x = 0; x < copyCols; x++) {
          newGrid[y][x] = oldGrid[y][x];
        }
      }

      grid = newGrid;
      drawGrid();
    }

    function drawGrid() {
      ctx.fillStyle =
        getComputedStyle(document.documentElement).getPropertyValue("--grid-dead") ||
        "#050608";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const aliveColor =
        getComputedStyle(document.documentElement).getPropertyValue("--grid-alive") ||
        "#27e8a7";

      ctx.fillStyle = aliveColor;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (grid[y][x]) {
            ctx.fillRect(
              x * cellSize,
              y * cellSize,
              cellSize - 1,
              cellSize - 1
            );
          }
        }
      }
    }

    function step() {
      const next = createEmptyGrid(rows, cols);

      const get = (y, x) => {
        // toroidal wrapping
        const yy = (y + rows) % rows;
        const xx = (x + cols) % cols;
        return grid[yy][xx];
      };

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let n =
            get(y - 1, x - 1) +
            get(y - 1, x) +
            get(y - 1, x + 1) +
            get(y, x - 1) +
            get(y, x + 1) +
            get(y + 1, x - 1) +
            get(y + 1, x) +
            get(y + 1, x + 1);

          if (grid[y][x]) {
            next[y][x] = n === 2 || n === 3 ? 1 : 0;
          } else {
            next[y][x] = n === 3 ? 1 : 0;
          }
        }
      }

      grid = next;
      drawGrid();
    }

    function loop() {
      if (!running) return;
      step();
      const delay = parseInt(speedSlider.value, 10);
      frameId = setTimeout(() => requestAnimationFrame(loop), delay);
    }

    function start() {
      if (running) return;
      running = true;
      runBtn.textContent = "Pause";
      loop();
    }

    function stop() {
      running = false;
      runBtn.textContent = "Run";
      if (frameId) {
        clearTimeout(frameId);
        frameId = null;
      }
    }

    function randomFill() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          grid[y][x] = Math.random() < 0.2 ? 1 : 0;
        }
      }
      drawGrid();
    }

    function clearGrid() {
      grid = createEmptyGrid(rows, cols);
      drawGrid();
    }

    function setTool(mode) {
      currentTool = mode;
      if (mode === "paint") {
        paintMode = "paint";
        currentStamp = null;
      } else if (mode === "erase") {
        paintMode = "erase";
        currentStamp = null;
      }

      paintBtn.classList.toggle("active", mode === "paint");
      eraseBtn.classList.toggle("active", mode === "erase");
    }

    function pointerPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const cx = Math.floor(x / cellSize);
      const cy = Math.floor(y / cellSize);
      if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) return null;
      return { cx, cy };
    }

    function applyPaint(evt) {
      const p = pointerPos(evt);
      if (!p) return;
      grid[p.cy][p.cx] = paintMode === "paint" ? 1 : 0;
      drawGrid();
    }

    // -------- Stamping beasts from Bestiary --------

    function stampPattern(name, centerRow, centerCol) {
      const pattern = PATTERNS[name];
      if (!pattern || pattern.length === 0) return;

      let minY = Infinity, maxY = -Infinity;
      let minX = Infinity, maxX = -Infinity;
      pattern.forEach(([py, px]) => {
        if (py < minY) minY = py;
        if (py > maxY) maxY = py;
        if (px < minX) minX = px;
        if (px > maxX) maxX = px;
      });

      const patRows = maxY - minY + 1;
      const patCols = maxX - minX + 1;

      const top = centerRow - Math.floor(patRows / 2);
      const left = centerCol - Math.floor(patCols / 2);

      pattern.forEach(([py, px]) => {
        const y = top + (py - minY);
        const x = left + (px - minX);
        if (y >= 0 && y < rows && x >= 0 && x < cols) {
          grid[y][x] = 1;
        }
      });

      drawGrid();
    }

    // -------- Event wiring --------

    // Pointer events
    canvas.addEventListener("pointerdown", (evt) => {
      const p = pointerPos(evt);
      if (!p) return;

      if (currentTool === "stamp" && currentStamp) {
        stampPattern(currentStamp, p.cy, p.cx);
        // stamp is click-only, do not enter drag mode
        return;
      }

      // paint / erase modes
      pointerDown = true;
      applyPaint(evt);
    });

    canvas.addEventListener("pointermove", (evt) => {
      if (!pointerDown) return;
      if (currentTool === "stamp") return;
      applyPaint(evt);
    });

    window.addEventListener("pointerup", () => {
      pointerDown = false;
    });

    window.addEventListener("pointercancel", () => {
      pointerDown = false;
    });

    // Toolbar buttons
    paintBtn.addEventListener("click", () => setTool("paint"));
    eraseBtn.addEventListener("click", () => setTool("erase"));
    randomBtn.addEventListener("click", () => randomFill());
    clearBtn.addEventListener("click", () => clearGrid());

    runBtn.addEventListener("click", () => {
      if (running) {
        stop();
      } else {
        start();
      }
    });

    // Bestiary open/close
    bestiaryBtn.addEventListener("click", () => {
      stop(); // pause while picking beasts
      bestiaryOverlay.classList.add("open");
    });

    closeBestiaryBtn.addEventListener("click", () => {
      bestiaryOverlay.classList.remove("open");
    });

    patternButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const name = btn.dataset.pattern;
        currentTool = "stamp";
        currentStamp = name;
        // Visually deselect paint/erase because we're stamping now
        paintBtn.classList.remove("active");
        eraseBtn.classList.remove("active");
        bestiaryOverlay.classList.remove("open");
      });
    });

    // Cell size slider
    cellSlider.addEventListener("input", () => {
      cellSize = parseInt(cellSlider.value, 10);
      resizeGrid();
    });

    // Window resize
    window.addEventListener("resize", () => {
      resizeGrid();
    });

    // Toolbar hide / show (corner button), preserving grid
    toggleUiBtn.addEventListener("click", () => {
      toolbarHidden = !toolbarHidden;
      toolbar.style.display = toolbarHidden ? "none" : "flex";
      toggleUiBtn.textContent = toolbarHidden ? "☰" : "⋮";
      resizeGrid();
    });

    // Initial setup
    window.addEventListener("load", () => {
      setTool("paint");
      resizeGrid();
      drawGrid();
    });
  </script>
</body>
</html>
